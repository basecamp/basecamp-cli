#!/usr/bin/env bash
# bcq - Basecamp Query CLI
# Agent-first CLI for Basecamp API interaction
#
# Usage: bcq <command> [options]
# Run 'bcq' with no arguments for quick-start guide

set -euo pipefail

# Determine script location for loading libs
BCQ_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
BCQ_VERSION="0.1.0"

# Load libraries
source "$BCQ_ROOT/lib/core.sh"
source "$BCQ_ROOT/lib/config.sh"
source "$BCQ_ROOT/lib/api.sh"
source "$BCQ_ROOT/lib/auth.sh"
source "$BCQ_ROOT/lib/help.sh"
source "$BCQ_ROOT/lib/names.sh"

# Load command handlers
for cmd_file in "$BCQ_ROOT/lib/commands"/*.sh; do
  [[ -f "$cmd_file" ]] && source "$cmd_file"
done


_self_update() {
  if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat <<'EOF'
bcq self-update - Update bcq to latest version

USAGE
  bcq self-update [--force]

REQUIREMENTS
  Only works for installer-based git installs:
  - Must have .git directory (not tarball extract)
  - Must be on a branch (not detached HEAD)
  - Branch must track origin (e.g., origin/main)

OPTIONS
  --force    Update even with local modifications or commits
             (uses git reset --hard instead of merge --ff-only)

EXAMPLES
  bcq self-update           Update current branch from origin
  bcq self-update --force   Force update, discarding local changes
EOF
    return 0
  fi

  local force=false
  [[ "${1:-}" == "--force" ]] && force=true

  # Detect Homebrew/Linuxbrew install
  if [[ "$BCQ_ROOT" == /opt/homebrew/* ]] || \
     [[ "$BCQ_ROOT" == /usr/local/Cellar/* ]] || \
     [[ "$BCQ_ROOT" == /home/linuxbrew/.linuxbrew/* ]]; then
    die "Homebrew installation detected" $EXIT_USAGE \
      "Update with: brew upgrade bcq"
  fi

  # Also check via brew --prefix if available
  if command -v brew &>/dev/null; then
    local brew_prefix
    brew_prefix=$(brew --prefix 2>/dev/null)
    if [[ -n "$brew_prefix" ]] && [[ "$BCQ_ROOT" == "$brew_prefix"/* ]]; then
      die "Homebrew installation detected" $EXIT_USAGE \
        "Update with: brew upgrade bcq"
    fi
  fi

  if [[ ! -d "$BCQ_ROOT/.git" ]]; then
    die "Not a git installation" $EXIT_USAGE \
      "Re-run installer: curl -fsSL https://raw.githubusercontent.com/basecamp/bcq/main/install.sh | bash"
  fi

  cd "$BCQ_ROOT"

  # Detect current branch or detached HEAD
  local branch
  branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

  if [[ -z "$branch" ]]; then
    die "Detached HEAD state" $EXIT_USAGE \
      "Checkout a branch first: git checkout main"
  fi

  # Check for upstream tracking branch
  local upstream
  upstream=$(git rev-parse --abbrev-ref "@{u}" 2>/dev/null || echo "")

  if [[ -z "$upstream" ]]; then
    die "No upstream configured for branch '$branch'" $EXIT_USAGE \
      "Set upstream: git branch -u origin/$branch"
  fi

  if [[ "$upstream" != origin/* ]]; then
    die "Upstream '$upstream' is not on origin" $EXIT_USAGE \
      "Re-run installer or set upstream to origin: git branch -u origin/$branch"
  fi

  # Check for local modifications
  if [[ "$force" != "true" ]] && ! git diff --quiet HEAD 2>/dev/null; then
    die "Local modifications detected" $EXIT_USAGE \
      "Commit or stash changes first, or use: bcq self-update --force"
  fi

  echo "Updating bcq ($branch from $upstream)..."

  local before after
  before=$(git rev-parse HEAD 2>/dev/null || echo "unknown")

  git fetch origin --quiet

  # Try fast-forward first, fall back to reset if --force
  if ! git merge --ff-only "$upstream" --quiet 2>/dev/null; then
    if [[ "$force" == "true" ]]; then
      git reset --hard "$upstream" --quiet
    else
      die "Cannot fast-forward" $EXIT_USAGE \
        "Local commits exist. Use: bcq self-update --force"
    fi
  fi

  after=$(git rev-parse HEAD 2>/dev/null || echo "unknown")

  if [[ "$before" == "$after" ]]; then
    echo "Already up to date (${after:0:7})"
  else
    echo "Updated: ${before:0:7} → ${after:0:7}"
    git log --oneline "${before}..${after}" 2>/dev/null | head -5
  fi
}

main() {
  # Extract global flags from anywhere in the argument list
  # This allows: bcq projects --json, bcq --json projects, bcq todos --json --in 123
  extract_global_flags "$@"
  # Use ${arr[@]+"${arr[@]}"} pattern for Bash 3.2 compatibility with empty arrays
  set -- ${BCQ_REMAINING_ARGS[@]+"${BCQ_REMAINING_ARGS[@]}"}

  # Reload config to pick up command-line flag overrides (e.g., --cache-dir)
  load_config

  # No arguments → quick-start
  if [[ $# -eq 0 ]]; then
    cmd_quick_start
    exit 0
  fi

  local command="$1"
  shift

  case "$command" in
    # Core commands (alphabetical)
    campfire)   cmd_campfire "$@" ;;
    cards)      cmd_cards "$@" ;;
    checkins)   cmd_checkins "$@" ;;
    comments)   cmd_comments "$@" ;;
    docs)       cmd_docs "$@" ;;
    events)     cmd_events "$@" ;;
    files)      cmd_files "$@" ;;
    forwards)   cmd_forwards "$@" ;;
    lineup)     cmd_lineup "$@" ;;
    me)         cmd_me "$@" ;;
    messages)   cmd_messages "$@" ;;
    messageboards) cmd_messageboards "$@" ;;
    messagetypes) cmd_messagetypes "$@" ;;
    people)     cmd_people "$@" ;;
    projects)   cmd_projects "$@" ;;
    recordings) cmd_recordings "$@" ;;
    schedule)   cmd_schedule "$@" ;;
    search)     cmd_search "$@" ;;
    show)       cmd_show "$@" ;;
    subscriptions) cmd_subscriptions "$@" ;;
    templates)  cmd_templates "$@" ;;
    timesheet)  cmd_timesheet "$@" ;;
    tools)      cmd_tools "$@" ;;
    todosets)   cmd_todosets "$@" ;;
    todolists)  cmd_todolists "$@" ;;
    todolistgroups) cmd_todolistgroups "$@" ;;
    todos)      cmd_todos "$@" ;;
    uploads)    cmd_uploads "$@" ;;
    vaults)     cmd_vaults "$@" ;;
    webhooks)   cmd_webhooks "$@" ;;

    # Action shortcuts
    todo)       cmd_todo_create "$@" ;;
    done)       cmd_todo_complete "$@" ;;
    reopen)     cmd_todo_uncomplete "$@" ;;
    message)    cmd_message "$@" ;;
    card)       cmd_card "$@" ;;
    comment)    cmd_comment "$@" ;;
    assign)     cmd_assign "$@" ;;
    unassign)   cmd_unassign "$@" ;;

    # Auth & config
    auth)       cmd_auth "$@" ;;
    config)     cmd_config "$@" ;;

    # Discovery
    commands)   cmd_commands "$@" ;;

    # MCP server
    mcp)        cmd_mcp "$@" ;;

    # Skill generation
    skill)      cmd_skill "$@" ;;

    # Meta
    version|--version|-V)
      echo "bcq $BCQ_VERSION"
      ;;
    self-update|update)
      _self_update "$@"
      ;;
    help|--help|-h)
      cmd_help "$@"
      ;;

    *)
      json_error "Unknown command: $command" "usage" \
        "Run 'bcq' for available commands"
      exit 1
      ;;
  esac
}

# Run main with all arguments
main "$@"
